<!DOCTYPE html>
<html>
<head>
  <script type="text/javascript"
  src="https://www.maths.nottingham.ac.uk/plp/pmadw/LaTeXMathML.js">
  </script>
  
<meta name="viewport" content="width=device-width, initial-scale=1">
<style>
body {
  margin: 0;
  font-family: Arial, Helvetica, sans-serif;
}

.top-container {
  padding: 30px;
  background-image:url('site_images/AmongUs.jpeg');
  background-repeat: no-repeat;
  background-position: center; 
  background-size: 100%;
  position: relative;
  object-fit: cover;
  width: auto;
  height: 150px;
}

.transbox {
  /* position: center; 
  width: 300px; */
  opacity: 0.8;
  height: 100px;
  margin: 30px;
  text-align: center;
  color: #ffffff;
  background-color: black;
}

/* .background {
  width:100%;
  height:auto;
}  */


.topnav {
  overflow: hidden;
  background-color: #333;
}

.topnav a {
  float: left;
  color: #f2f2f2;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
  font-size: 17px;
}

.topnav a:hover {
  background-color: #ddd;
  color: black;
}

.topnav a.active {
  background-color: #04AA6D;
  color: white;
}

.content {
  padding: 16px;
}

.sticky {
  position: fixed;
  top: 0;
  width: 100%;
}

.sticky + .content {
  padding-top: 102px;
}
</style>
</head>
<body>

<div class="top-container">
  <div class="transbox" >
  <h1>Among Us</h1>
  <p>Group 19: Logical Aspects of Multi-Agent Systems.</p>
  </div>
</div>

<div class="topnav" id="nav">
  <a href="#what_is_among_us">Introduction</a>
  <a href="#kripke_model">Model</a>
  <a href="#knowledge_types">Knowledge</a>
  <a href="#reasoning_rules">Rules</a>
  <!-- <a href="#findings">Findings</a> -->
  <a href="#technical_details">Technical Details</a>
  <a href="#extended-knowledge-model-movement-between-rooms">Extensions</a>
  <a href="https://github.com/MaxVinValk/AmongUsLAMAS">GitHub</a>
</div>

<div class="content">
  <a id="what_is_among_us"></a>
  <h3>What is Among Us?</h3>
  <p>In this game, each agent gets assigned a role: either crewmate or imposter. As a crewmate, your objective is to complete tasks to safe the ship. As an imposter, you have to prevent this from happening by killing the crewmates without anyone noticing.</p>
  <p>In short, the game exists of two phases: playing and communicating. In the first phase, all agents can walk around a map and perform several actions, such as performing a task to help the ship when you are a crewmate, or killing off a crewmate when you are an imposter. The latter, communication, phase is triggered when a crewmate finds a dead crewmate. In this phase, all agents share their last location and their knowledge about which agents are safe or not. The tricky part here is that the crewmates share this truthfully, but the imposter does not. The crewmates therefore have to figure out who is the corrupt agent by either catching them in the act of killing a crewmate, or catching them in a lie. They also have to reason with the knowledge of the other agents, but they have to watch out not to reason with the false imposter's announcements.</p>
  
  <h4>Formalizing Among Us</h4>
  <p><strong>Action Phase</strong>: The action phase consists out of two phases itself: acting and observing. In the first phase, all agents can either move to an adjacent room or perform an action, which is a task if they are crewmate, or kill if they are imposter. They can also choose to perform no action and not move. This phase is repeated until a crewmate runs into a dead body, in which case the agent can report the body at the end of the action phase. This triggers the discussion phase.<br />
    <p></p><strong>Discussion Phase</strong>: The discussion phase is started with an announcement of which agent has died and in which room. Then, each agent announces their location at the last five (exact number to be defined) timesteps. In case the imposter has to announce they were last in the room where the dead body was now found, the imposter will instead announce a random location. Every agent can then reason using the ’catch in a lie’ rule, and finally present the agents that they still consider to be possible imposters. The imposter here announces all remaining agents minus one random agent each discussion phase. <br />
    <p></p><strong>Voting Phase</strong>: In the voting phase, initially, we plan to model that each agent only votes if they know for sure who the imposter is. Otherwise, they skip the vote. If the majority then votes out the imposter, the crewmates win. We can experiment with the voting behaviour of the impostor and with different voting strategies for the crewmates. For example, agents could vote randomly on agents that they still consider suspicious instead of skipping.</p>
    <p></p><p>The game can end in three possible ways:</p>
  <ul>
  <li><p>The imposter is voted out by the majority, meaning that the crewmates win.</p></li>
  <li><p>All crewmates completed all of their assigned tasks, meaning that they win.</p></li>
  <li><p>Only one crewmate is left, which means the imposter wins.</p></li>
  </ul>
  
  <a id="kripke_model"></a>
  <h3>Kripke Model</h3>
  <p>Our proposed Kripke model for the overview of the game is relatively simple, as all agents only need to figure out which agent is the imposter. The imposter knows that they are the imposter. Here, all straight lines represent bidirectional arrows. </p>
  <img src="site_images/KM.jpg" alt="Kripke Model" style="width:auto;height:600px;">

  <a id="knowledge_types"></a>
  <h3>Knowledge Types</h3>
  <p>There are however types of knowledge that can be learned throughout the game. Here, a<sub>1</sub> and a<sub>2</sub> $\in$ set of agents A, x<sub>1</sub> and x<sub>2</sub>$\in$ set of rooms X and y $\in$ set of timesteps Y. These are types of knowledge that can be gained by any crewmate while in the action-phase:</p>
  <ul>
      <li>The location of an agent (both itself and other agents). For example, a<sub>1</sub> is in room x<sub>1</sub> at time y.</li>
      <li>Whether an agent performed a visual task. For example, a<sub>1</sub> performed a visual task in room x<sub>1</sub> at time y.</li>
  </ul>
  <p>For both of these types of knowledge to be gained, it is important that a crewmate a<sub>1</sub> is in the same room as agent a<sub>2</sub> (where a<sub>1</sub> <span>&#8800;</span>
     a<sub>2</sub>) at the same time.

      In the discussion phase, all agents encounter two other possible knowledge types:</p>
  <ul>
    <li>Whether an agent is dead or alive. For example, a<sub>1</sub> is alive at time y.</li>
    <li>Announcements of location. For example, a<sub>1</sub> announces that they were in room x at time y.</li>

  </ul>
  <p> With these different types of knowledge, a crewmate can then reason about the final type of knowledge. Namely, whether another agent is an imposter or not.</p>
  
  <a id="reasoning_rules"></a>
  <h3>Reasoning Rules</h3>
  <p>There are several rules a crewmate (here a<sub>1</sub>) can use to deduct this final important type of knowledge. They are listed as follows:</p>
  <ul>
      <li>Catching the imposter in the act: (a<sub>1</sub> is in the same room x<sub>1</sub> as a<sub>2</sub> at step y $\land$ a<sub>3</sub> is dead) $\rightarrow$ a<sub>1</sub> knows a<sub>2</sub> is the imposter.</li>
  
      <li>Catching the imposter in a lie: (a<sub>1</sub> is in the same room x<sub>1</sub> as a<sub>2</sub> at time y $\land$ a<sub>2</sub> announces they were at room x<sub>2</sub> (x<sub>2</sub> <span>&#8800;</span> x<sub>1</sub>) at y) $\rightarrow$ a<sub>1</sub> knows a<sub>2</sub> is the imposter.</li>
  
      <li>Clearing a crewmate by seeing their task: (a<sub>1</sub> is in the same room x<sub>1</sub> as a<sub>2</sub> at step y $\land$ a<sub>2</sub> performed a visual task in room x<sub>1</sub> at step y) $\rightarrow$ a<sub>1</sub> knows a<sub>2</sub> is a crewmate.</li>
  
      <li>Dead agents must be crewmates: a<sub>1</sub> is dead $\rightarrow$ all a know that a<sub>1</sub> a crewmate.</li>
   
      </ul>
  
  <p>To model the real game, the imposter will have a cooldown of a set number of rounds on their kill-action. When it is capable of killing a crewmate, this action is stochastic. This means that simply being in the same room as another agent without getting killed does not mean that they are a crewmate. 
  
  In our initial knowledge model, the imposter does not yet reason about what the other agents know. We do plan to explore this using higher-order knowledge once the initial project is up and running. </p>

  <p>We also still want to explore the concept of lying for the imposter. This way, the imposter could lie about their last location in case this location was the kill site. We have not implemented or researched this yet.</p>

  <!-- <a id="findings"></a>
  <h3>Findings</h3> -->

  <a id="technical_details"></a>
  <h3>Techincal Details</h3>
<p>We have implemented most of the game mechanics and a simple gui in PyGame, and our code can be found in this repository: <a href="https://github.com/MaxVinValk/AmongUsLAMAS">https://github.com/MaxVinValk/AmongUsLAMAS</a>. The agents follow a hard-coded strategy in our implementation, apart from the voting phase. Our next step is to extend the implementation with Kripke models. We use <a href="https://github.com/erohkohl/mlsolver">https://github.com/erohkohl/mlsolver</a> to implement our Kripke model. For now, the model is still simple and only contains knowledge about which agent is the imposter. Later, we will try to extend this Kripke model as described in the next section.</p>

<a id="extended-knowledge-model-movement-between-rooms"></a>
<h3>Extended Knowledge Model: Movement between Rooms</h3>

<p>In the basic knowledge model, when a crewmate learns someone was in a room he will take this into consideration, but will not use the movement rules to infer where that person could be in the previous or next step. This information is often relevant, for example when <span class="math inline">a_1</span> sees <span class="math inline">a_2</span> at the left of the map, and in the next time step <span class="math inline">a_3</span> is killed at the right end of the map, this means <span class="math inline">a_1</span> can infer that <span class="math inline">a_2</span> cannot be the killer because he cannot have traveled across the map that quickly. We have thought about ways to extend our approach to make this kind of inference possible, which we might implement and compare if we have the time.</p>
<p>It is not feasible to construct a single Kripke model encoding the location of all agents at all time steps due to the curse of dimensionality. An alternative is to construct a set of disconnected models representing knowledge about subsets of the propositions about the game world. A reasonable simplification might be to construct one Kripke model for every combination of time step and agent (so for example in a game with 5 agents where 10 time steps have passed, there would be 50 such models). The location model for agent <span class="math inline">a_i</span> at time <span class="math inline">t</span> will be denoted <span class="math inline">M^\mathsf{loc}_{a_i,t}</span> and has the following propositional atoms:</p>
<p><span class="math display">P^\mathsf{loc}_{a_i,t} = \{\mathsf{room}_{a_i;r;t} | r \in R\} \cup \{ \mathsf{imp}_a | a \in A\},</span> where <span class="math inline">\mathsf{room}_{a_i;r;t}</span> indicates <em><span class="math inline">a_i</span> was in room <span class="math inline">r</span> at time <span class="math inline">t</span></em> and <span class="math inline">\mathsf{imp}_a</span> indicates <em>agent <span class="math inline">a</span> is the impostor</em>.</p>
<p>We know that there is exactly one impostor in the game and that an agent is in one room at any time. Therefore, the states in a location model consist of one <span class="math inline">\mathsf{room}</span> proposition and one <span class="math inline">\mathsf{imp}</span> proposition. Initially, accessibility relations are those for a distributed system (agents know their own location and impostor status, but not those of others). So initially, it holds that <span class="math inline">i \neq j \Leftrightarrow M^\mathsf{loc}_{a,t} \vDash \neg K_i \mathsf{imp}_j \land \neg K_i \neg \mathsf{imp}_j</span> unless <span class="math inline">a_i</span> is the impostor (which means he knows the impostor status of all agents).</p>
<p>Now the types of knowledge obtained by the agents during the game can be translated into announcements for the location models. This will restrict the accessibility relations, and at some point some agents may acquire knowledge that someone is or is not the impostor and use this to inform their voting. A sketch of how these announcements could work is the following (announcements are made only to the agent that learn that information, which we could model with an epistemic action model):</p>
<ul>
<li><p><em>Learning agent <span class="math inline">a</span> is in room <span class="math inline">r</span> at time <span class="math inline">t</span>:</em> In the location model <span class="math inline">M^\mathsf{loc}_{a,t}</span> this is translated as the announcement of proposition <span class="math inline">\mathsf{room}_{a;r;t}</span>. We can also translate this announcement to other time steps, by using the connectivity between the rooms. For example we know that in the previous time step, agent <span class="math inline">a</span> was in a room from which <span class="math inline">r</span> was reachable, so in model <span class="math inline">M^\mathsf{loc}_{a,t-1}</span> we can announce for all rooms <span class="math inline">r^\prime</span> that are not connected to <span class="math inline">r</span> that <span class="math inline">\neg\mathsf{room}_{a;r^\prime;t-1}</span> (meaning agent <span class="math inline">a</span> was certainly not in any of those rooms). In this way the observation can be translated to the location models of agent <span class="math inline">a</span> for all time steps.</p></li>
<li><p><em>In the discussion phase, an agent <span class="math inline">a</span> announces the location of an agent at some time:</em> We can exclude all states that contradict the announced location and where <span class="math inline">a</span> is not the impostor (because only the impostor can lie). We can again use the connectivity to translate this announcement to other time steps.</p></li>
<li><p><em>Visual task is observed of some agent <span class="math inline">a</span>:</em> We can announce to the observing agent that <span class="math inline">\neg \mathsf{imp}_a</span>.</p></li>
</ul>
<p>This needs to be worked out more carefully, but it would be interesting to see how much of an advantage the agents would get by adding this type of reasoning. The combined size of the models is much larger than the basic knowledge model, but seems like it should be manageable if implemented efficiently. If we choose to implement it this model can also easily be extended for the <em>venting</em> mechanic where the impostor can take shortcuts, to allow crewmates to notice the impostor moved too quickly.</p>
<p>It would be interesting to know if there is a more elegant way to deal with this kind of knowledge that creating a set of separate Kripke models.</p>
</div>

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
   extensions: ["jsMath2jax.js"]
 });
</script>

<script
 src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
</script>


<script>

// The function actually applying the offset
function offsetAnchor() {
    if(location.hash.length !== 0) {
        window.scrollTo(window.scrollX, window.scrollY - 65);
    }
}

// This will capture hash changes while on the page
window.addEventListener("hashchange", offsetAnchor);

// This is here so that when you enter the page with a hash,
// it can provide the offset in that case too. Having a timeout
// seems necessary to allow the browser to jump to the anchor first.
window.setTimeout(offsetAnchor, 1); // The delay of 1 is arbitrary and may not always work right (although it did in my testing).

window.onscroll = function() {myFunction()};

var header = document.getElementById("nav");
var sticky = header.offsetTop;

function myFunction() {
  if (window.pageYOffset > sticky) {
    header.classList.add("sticky");
  } else {
    header.classList.remove("sticky");
  }
}

function openCity(cityName,elmnt,color) {
  var i, tabcontent, tablinks;
  tabcontent = document.getElementsByClassName("tabcontent");
  for (i = 0; i < tabcontent.length; i++) {
    tabcontent[i].style.display = "none";
  }
  tablinks = document.getElementsByClassName("tablink");
  for (i = 0; i < tablinks.length; i++) {
    tablinks[i].style.backgroundColor = "";
  }
  document.getElementById(cityName).style.display = "block";
  elmnt.style.backgroundColor = color;

}
// Get the element with id="defaultOpen" and click on it
document.getElementById("defaultOpen").click();
</script>

</body>
</html>
